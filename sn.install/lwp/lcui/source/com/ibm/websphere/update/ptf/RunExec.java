/* ***************************************************************** */
/*                                                                   */
/* IBM Confidential                                                  */
/*                                                                   */
/* OCO Source Materials                                              */
/*                                                                   */
/* Copyright IBM Corp. 2011, 2015                                    */
/*                                                                   */
/* The source code for this program is not published or otherwise    */
/* divested of its trade secrets, irrespective of what has been      */
/* deposited with the U.S. Copyright Office.                         */
/*                                                                   */
/* ***************************************************************** */

/* @copyright module */
package com.ibm.websphere.update.ptf;

/*
 * RunExec
 *
 * History "1.1", "1/15/03"
 *
 * 13-Jan-2003 Initial Version
 *
 *
 */

import java.io.*;
import java.lang.Runtime;
import java.util.*;

/**
 * Utility class for running platform-specific executables.
 */
public class RunExec implements Runnable {

    private StringBuffer result = new StringBuffer(1000);
    private boolean noPrint = false;
    private int rvalue = 0;
    private int timeout = 0;
    private int countdown = 0;
    private Thread mainOne = null;

    /**
     * Starts a process to execute a command. Returns immediately,
     * even if the new process is still running.
     */
    public boolean exec(String command) {
        return (exec(command, false, false));
    }

    /**
     * Starts a process to execute a command and waits for the process to
     * finish before returning.
     */
    public boolean execWait(String command) {
        return (exec(command, false, true));
    }

    /**
     * Starts a process to execute the command and prints all output the
     * executing program generates.
     */
    public boolean execPrint(String command) {
        noPrint = false;
        return (exec(command, true, false));
    }

    /**
     * Starts a process to execute the command and returns all output that the
     *  executing program generates.
     */
    public String execGetOutput(String command) {
        noPrint = true;
        exec(command, true, false);
        return result.toString();
    }

    /**
     * Get the output generated by the executing program when called
     * using execPrint()
     */
    public String getOutput() {
        return result.toString();
    }

    /**
     * Get the return code of the executing program
     */
    public int getReturnCode() {
        return rvalue;
    }

    private boolean exec(String command, boolean printResults, boolean wait) {

        if (timeout > 0) {
            mainOne = Thread.currentThread();
            Thread newOne = new Thread(this);
            newOne.start();
            countdown = timeout;
        }

        try {
            Process p = Runtime.getRuntime().exec(command);
            if (printResults) {

                InputStreamReader commandResult = new InputStreamReader(new BufferedInputStream(p.getInputStream()));
                StringBuffer s = new StringBuffer();
                String ls = System.getProperty("line.separator");
                try {
                    int b = 0;
                    boolean eol = false;

                    while (b != -1) {

                        b = commandResult.read();
                        if (b != -1) {
                            countdown = timeout;
                            if (b == '\n') {
                                result.append(s.toString() + "\n");
                                s = new StringBuffer();
                            }
                            else {
                                s.append((char) b);
                            }
                        }
                    }
                    rvalue = p.waitFor();
                    if ((rvalue != 0) && (rvalue < 256)) {
                        printError(command + " (" + "RunExec.ReturnCode" + " = " + p.exitValue() + ")");
                        timeout = 0;
                        return (false);
                    }
                }
                catch (Exception e) {
                    e.printStackTrace();
                }

            }
            else if (wait) {
                try {
                    int returnVal = p.waitFor();
                    if (returnVal != 0) {
                        printError(command);
                        timeout = 0;
                        return (false);
                    }
                }
                catch (Exception e) {
                    printError(command, e);
                    timeout = 0;
                    return (false);
                }
            }
        }
        catch (Exception e) {
            printError(command, e);
            timeout = 0;
            return (false);
        }
        timeout = 0;
        return (true);
    }

    private void printError(String command, Exception e) {}

    private void printError(String command) {}

    /**
	 * @param timeout  the timeout to set
	 * @uml.property  name="timeout"
	 */
    public void setTimeout(int tout) {
        timeout = tout;
    }

    public void run() {
        while (timeout > 0) {
            try {
                Thread.sleep(1000);
                countdown = countdown - 1000;
                if (countdown <= 0) {
                    System.exit(1);
                }
            }
            catch (Exception e) {}
        }
    }

}