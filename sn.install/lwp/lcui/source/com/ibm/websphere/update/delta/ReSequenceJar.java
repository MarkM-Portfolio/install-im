/* ***************************************************************** */
/*                                                                   */
/* IBM Confidential                                                  */
/*                                                                   */
/* OCO Source Materials                                              */
/*                                                                   */
/* Copyright IBM Corp. 2011, 2015                                    */
/*                                                                   */
/* The source code for this program is not published or otherwise    */
/* divested of its trade secrets, irrespective of what has been      */
/* deposited with the U.S. Copyright Office.                         */
/*                                                                   */
/* ***************************************************************** */

/* @copyright module */
package com.ibm.websphere.update.delta;
//  Re-sequence a Jar File

import java.io.*;
import java.util.zip.*;
import java.util.jar.*;
import java.util.*;
import java.text.SimpleDateFormat;


//scan4err Error(     in support of automated Error number checking


/** Re-sequence the entries with in a jar file. */
public class ReSequenceJar {

   public static final String pgmVersion = "1.3" ;
   public static final String pgmUpdate = "4/29/04" ;

  static String className  = "ReSequenceJar";

  static Vector msg;   // This collects all output messages

  static boolean didInform;     // to track if we ever informed the observer
  static long    nextTime;      // the time of the next screen update
  static int     entryCount;    // the number of jar entries
  static String  strEntryCount; // the entryCount in string format
  static int     entryCountLen; // the length of the strEntryCount
  static int     currentCount;  // the entry we are currently working on


/**  Constructor for ReSequence a Jar File
 * Parm 1 is a Vector to receive all messages, including errors,  generated by the
 *        re-sequence process. This value may be null, in which case all messages
 *        will be sent to StdOut or StdErr
*/

 public ReSequenceJar(Vector msg) {
   ReSequenceJar.msg = msg;
 }



//ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
//บ                  Re-Sequence a Jar File                       บ
//ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
public boolean reSequence(String jarFileName, InputStream sequenceFile, int compression) {

 JarFile inJar;
 Manifest manifest;

 nextTime = System.currentTimeMillis() + 5000;  // First update in 5 seconds
 currentCount = 0;
 didInform    = false;


 try {      // open the input jar
   inJar = new JarFile(jarFileName, false);
   entryCount = inJar.size() - 1;
   strEntryCount = Integer.toString(entryCount);
   entryCountLen = strEntryCount.length();
   logMsg(strEntryCount + " entries in the jar file.");
 } catch (IOException ex) {
    logError(3, "IOException opening " + jarFileName, ex);
    return false;
 }

 try {      // fetch the manifest
   manifest = inJar.getManifest();
   if (manifest == null) {
     logMsg( " No manifest.");
   } else {
     currentCount++;
     Map   mfMap = manifest.getEntries();
     logMsg( mfMap.size() + " entries in the manifest.");
   }

 } catch (IOException ex) {
   logError(4, "IOException in obtaining the manifest from " + jarFileName, ex);
   return false;
 }


               // fillin the jeht hashtable and the origSeq Vector
 JarInputStream jis;

 try {
   jis = new JarInputStream(new FileInputStream(jarFileName), false);
 } catch (IOException ex) {
   logError(5, "IOException opening " + jarFileName, ex);
   return false;
 }

 Vector    origSeq  = new Vector(entryCount);    // this contains the original sequence of the jar entries
 Hashtable jeht     = new Hashtable(entryCount); // this contains the Jar Entries and the entry name is the key
 JarEntry  jarEntry;

 try {     // here we will put all the jar entries into the jeht hashtable

   while ((jarEntry = jis.getNextJarEntry()) != null  ) {

     if (jarEntry.isDirectory() == true ) {
       origSeq.add(jarEntry.getName());
       jeht.put(jarEntry.getName().replace('\\', '/') ,jarEntry);

     } else {        // it must be a file

       String jarEntryName = jarEntry.getName();

       if (jarEntryName.equalsIgnoreCase("META-INF/MANIFEST.MF") ||  jarEntryName.equalsIgnoreCase("META-INF\\MANIFEST.MF") ) {
         logMsg("Ignoring manifest as file, processed as manifest.");

       } else {
         origSeq.add(jarEntry.getName());
         jeht.put(jarEntry.getName().replace('\\', '/') ,jarEntry);
       }
     }
   }

 } catch (IOException ex) {
   logError(6,"IOException", ex);
   return false;
 }

 inform();



              // create a temporary jar file in the same directory as the real jar file

 File tmpJarFile;
 String tmpJarName;
 File directory = determineDirectory(jarFileName);


 try {
   tmpJarFile = File.createTempFile("tmpjar", null, directory);
   tmpJarName = tmpJarFile.toString();
   logMsg("Temporary jar file name: " + tmpJarName);

 } catch ( IOException ex ) {
   logError(7, "IOException generating temporary jar file name", ex);
   return false;
 }


 JarOutputStream tmpJarOutput;

 try {
   FileOutputStream tmpJarStream = new FileOutputStream(tmpJarFile);

   if (manifest == null)
     tmpJarOutput = new JarOutputStream(tmpJarStream);
   else
     tmpJarOutput = new JarOutputStream(tmpJarStream, manifest);

 } catch ( IOException ex ) {
   logError(8, "IOException opening temporary jar file " + tmpJarName, ex);
   return false;
 }

 tmpJarOutput.setLevel(compression);


              // now process the sequence file, removing the entries from the jeht
              // as we use them
 BufferedReader bufIn  = new BufferedReader(new InputStreamReader(sequenceFile));

 String seqReq;

 while ((seqReq = nextSeqReq(bufIn)) != null) {

   if (jeht.containsKey(seqReq)) {
     logMsg("Valid request  : " + seqReq);
     JarEntry je = (JarEntry) jeht.get(seqReq);

     if (transfer(inJar, je,  tmpJarOutput, seqReq) == false)
       return false;

     jeht.remove(seqReq);

   } else     // we ignore requests for non-existant objects
     logMsg("Non-existent object : " + seqReq);

   inform();
 }


              // now writeout the remaining entries in their original sequence

 Enumeration ele = origSeq.elements();
 while (ele.hasMoreElements()) {
   String key = (String) ele.nextElement();

   if (jeht.containsKey(key)) {
     logMsg("Original entry : " + key);
     JarEntry je = (JarEntry) jeht.get(key);

     if (transfer(inJar, je, tmpJarOutput, key) == false)
       return false;

     jeht.remove(key);

     inform();
   } // skip any entries not found, we probably output them earlier
 }



              // now transfer any objects remaining in jeht, there should be none
 Enumeration keys = jeht.keys();
 while (keys.hasMoreElements()) {
   String key = (String) keys.nextElement();
   logMsg("LeftOver entry : " + key);
     JarEntry je = (JarEntry) jeht.get(key);

     InputStream iStream;

     try {
       iStream = inJar.getInputStream(je);
     } catch (IOException ex) {
       logError(14, "Failure getting jar inputStream", ex);
       return false;
     }

     if (transfer(inJar, je, tmpJarOutput, key) == false)
       return false;

     jeht.remove(key);

     inform();
 }


 if (didInform) {
   nextTime = 0;
   inform();
 }

 try {
   inJar.close();
   jis.close();
   tmpJarOutput.close();
 } catch (IOException ex) {
   logError(12, "Failure to close", ex);
   return false;
 }

              // delete the input file and rename the temp file to the old name

 File oldFile = new File(jarFileName);
 if (oldFile.delete()) {

   if (tmpJarFile.renameTo(oldFile)) {
     logMsg("Rename successful");
   } else {
     logError(19, "Unable to rename "+ tmpJarFile.toString() +" to "+ jarFileName, null);
     return false;
   }

 } else {
   logError(18, "Unable to delete input jar file "+ oldFile.toString(), null);
   return false;
 }

 return true;
}



//ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
//บ                   Keep an observer updated                    บ
//ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
protected void inform() {
 final boolean rightJustify = false;
 final char filler = ' ';

 if (System.currentTimeMillis() > nextTime ) {

   int pct = 0;
   if (entryCount == 0) {
     pct = 0;
   } else
     pct = (currentCount*100) / entryCount;

   String strPct = pad(Integer.toString(pct), 3, rightJustify, filler);

   Date Now = new Date();
   SimpleDateFormat df = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
   String currentTimeStamp = df.format(Now);

   String cc = Integer.toString(currentCount);
   System.out.println(currentTimeStamp    +
                      " Processing entry "+
                      pad(cc, entryCountLen, rightJustify, filler)  +
                      " of "+
                      pad(strEntryCount, entryCountLen, rightJustify, filler) +
                      "   "+
                      strPct+"% complete");
   didInform = true;
   nextTime = System.currentTimeMillis() + 4000; // update screen every 4 seconds
 }

 return;
}


//ษออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
//บ                            Pad a string                            บ
//ศออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
private String pad(String input, int length,  boolean leftJustify, char ch) {

 if (input.length() >= length)
   return input;

 int delta = length - input.length();
 StringBuffer sb = new StringBuffer(delta);

 for (int i=0; i<delta; i++)  sb.append(ch);

 if (leftJustify)
   return input.concat(sb.toString());
 else
  return sb.toString().concat(input);

}


//ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
//บ              Read a line from the sequence file               บ
//ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
protected String nextSeqReq(BufferedReader bufIn) {

 try {
  String str = bufIn.readLine();
  if (str != null)
    str =  str.replace('\\', '/');
  return str;

 } catch (IOException ex) {
 logError(16, "IOException reading sequence file",  ex);
 }

 return null;
}

//ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
//บ       Transfer an object from one jar file to another         บ
//ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
protected boolean transfer(JarFile jar, JarEntry je, JarOutputStream jos, String entryName) {

 currentCount++;
 final int jarBufferSize = 10 * 2048;
 byte[] IOBuf = new byte[jarBufferSize];
 JarEntry transferEntry = new JarEntry(entryName);


 InputStream jis;

 try {
   jis = jar.getInputStream(je);
 } catch (IOException ex) {
   logError(15, "Failure getting jar inputStream", ex);
   return false;
 }



 try {
   jos.putNextEntry(transferEntry); // kick off the new entry
 } catch ( IOException ex ) {
   logError(17, "IOException setting new jar entry " + entryName, ex);
   return false;
 }

 long totRead = 0;

 try {
   int bytesRead = jarBufferSize;

   while ( bytesRead > 0 ) {
     bytesRead = jis.read(IOBuf, 0, jarBufferSize);

     if ( bytesRead > 0 ) {
       totRead += bytesRead;
       jos.write(IOBuf, 0, bytesRead);
     }
   }
 } catch ( IOException ex ) {
   logError(44, "IOException transferring jar entry "+ entryName, ex);
   return false;
 }

 logMsg("   "+ totRead +" bytes transfered.");
 return true;
}



//ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
//บ                      extract directory                        บ
//ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
File determineDirectory(String aFileName) {

 String dirStr = null;

 File file       = new File(aFileName);
 String filespec = file.getAbsolutePath();
 filespec        = filespec.replace('\\', '/');

 int pos = filespec.lastIndexOf("/");
 if (pos == -1) {
   logError(9, "Could not extract path from ("+ filespec +")", null);
   return null;
 }

 dirStr = filespec.substring(0, pos);

 File directory = new File(dirStr);

 if (!directory.isDirectory()) {
   logError(10, "Extracted path is not a directory ("+ filespec +")", null);
   return null;
 }

 return directory;
}


//ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
//บ                  Process an error message                     บ
//ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
void logError(int errorNum, String text, Exception ex) {

 String ePrefix = "Error "+ errorNum +" in "+ className +".class -- ";
 String exText;

 if (ex == null)
   exText = ".";
 else
   exText = "; "+ ex.getMessage();

 logMsg(ePrefix + text + exText);

 return;
}

//ษอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออป
//บ              Add a Message to the  msg Vector                 บ
//ศอออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออออผ
void logMsg(String text) {

 if (msg == null)
   System.out.println(text);
 else
   msg.add(text);

 return;
}


}
